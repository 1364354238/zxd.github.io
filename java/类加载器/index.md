# 类加载器classloader

## 类加载的过程
1.加载：将字节码文件加载到JRE中

2.验证：保证加载进来的字节流符合jvm规范，不会造成安全区错误

3.准备：为类变量（静态变量）分配内存，并且赋予初值（jvm根据变量类型赋予的默认初值）

4.解析：jvm会将所有的类名，方法名，字段名这些符号引用替换为具体的内存地址和偏移量，也就是直接引用

5.初始化：这个阶段主要对类变量初始化（只对static修饰的变量或语句初始化，先初始化父类才能初始化子类，自上而下初始化）

> 后四步主要由jvm控制，人为干预空间不多，加载可通过classloader控制

## classloader
1.双亲委托机制
指多个类加载器之间存在父子关系，当一个类需要去加载时，它首先不会去加载，而是委托给自己的顶端父类加载器（Bootstrap classloader）加载，
如果父类自己无法完成这个加载请求，则子加载器会尝试自己加载。

该机制能够避免类的重复加载，并且可以避免核心类被不同的类加载器加载造成的冲突和混乱，保证了java核心库的安全。

2.加载优先级

- 启动类加载器（Bootstrap Classloader）：负责将<JAVA_HOME>/lib目录下并且被jvm识别的库加载到jvm内存当中。
- 扩展类加载器（Extension Classloader）：负责加载jvm扩展类（位于<JAVA_HOME>/lib/ext）
- 应用程序类加载器（Application Classloader）：系统类加载器，负责加载<classpath>上指定的类库（自己编写的代码和第三方jar包）
- 自定义加载器（Custom Classloader）：为实现特殊目的，自定义实现的加载器（这些加载器优先级是平行的）
  
## classloader应用场景 
  1.依赖冲突
  
  2.热加载（修改双亲加载机制，默认优先从自己在加载）
  
  3.热部署
  
  4.加密保护（通过classloader对jar包进行加密）



